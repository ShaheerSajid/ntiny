
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module de1soc(

	//////////// CLOCK //////////
//	input 		          		CLOCK2_50,
//	input 		          		CLOCK3_50,
//	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	inout 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	inout 		     [9:0]		SW,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_0,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1,
	
	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK
);


//=======================================================
//  REG/WIRE declarations
//=======================================================
	
	wire scl_pad_i;
	wire scl_pad_o;
	wire scl_padoen_o;
	wire sda_pad_i;
	wire sda_pad_o;
	wire sda_padoen_o;



	wire [31:0]num;
	hex_out h5(.data(num[23:20]) ,.out(HEX5));
	hex_out h4(.data(num[19:16]) ,.out(HEX4));
	hex_out h3(.data(num[15:12]) ,.out(HEX3));
	hex_out h2(.data(num[11:8])  ,.out(HEX2));
	hex_out h1(.data(num[7:4]) ,.out(HEX1));
	hex_out h0(.data(num[3:0]) ,.out(HEX0));



	wire [14:0] address_a_sig;
	wire [14:0] address_b_sig;
	wire [3:0] byteena_a_sig;
	wire [3:0] byteena_b_sig;
	wire  clock_a_sig;
	wire  clock_b_sig;
	wire [31:0] data_a_sig;
	wire [31:0] data_b_sig;
	wire  enable_a_sig;
	wire  enable_b_sig;
	wire  wren_a_sig;
	wire  wren_b_sig;
	wire [31:0] q_a_sig;
	wire [31:0] q_b_sig;
  wire	[31:0]  q_boot_sig;
	
//=======================================================
//  Structural coding
//=======================================================

  //make boot memory and keep feeding it address_a_sig
  //if boot memory select boot memory readdata
reg [31:0] cnt = 0;
wire rst;
always@(posedge CLOCK_50)
begin
  if(cnt < 32'd25000000)
    cnt <= cnt+1;
end
assign rst = cnt < 32'd25000000;

	mem mem_inst
	(
		.address_a(address_a_sig) ,	// input [14:0] address_a_sig
		.address_b({3'b100,address_b_sig[11:0]}) ,	// input [14:0] address_b_sig
		.byteena_a(byteena_a_sig) ,	// input [3:0] byteena_a_sig
		.byteena_b(byteena_b_sig) ,	// input [3:0] byteena_b_sig
		.clock_a(clock_a_sig) ,	// input  clock_a_sig
		.clock_b(clock_b_sig) ,	// input  clock_b_sig
		.data_a(data_a_sig) ,	// input [31:0] data_a_sig
		.data_b(data_b_sig) ,	// input [31:0] data_b_sig
		.enable_a(enable_a_sig) ,	// input  enable_a_sig
		.enable_b(enable_b_sig) ,	// input  enable_b_sig
		.wren_a(wren_a_sig) ,	// input  wren_a_sig
		.wren_b(wren_b_sig) ,	// input  wren_b_sig
		.q_a(q_a_sig) ,	// output [31:0] q_a_sig
		.q_b(q_b_sig) 	// output [31:0] q_b_sig
	);

  bootmem	bootmem_inst (
    .address ( address_a_sig ),
    .clken ( enable_a_sig ),
    .clock ( clock_a_sig ),
    .q ( q_boot_sig )
  );


/*
	vga_adapter VGA(
			.resetn(KEY[0]),
			.clock(CLOCK_50),
			.colour(num[2:0]),
			.x(num[10:3]),
			.y(num[17:11]),
			.plot(num[18]),
			.VGA_R(VGA_R),
			.VGA_G(VGA_G),
			.VGA_B(VGA_B),
			.VGA_HS(VGA_HS),
			.VGA_VS(VGA_VS),
			.VGA_BLANK(VGA_BLANK_N),
			.VGA_SYNC(VGA_SYNC_N),
			.VGA_CLK(VGA_CLK));
		defparam VGA.RESOLUTION = "160x120";
		defparam VGA.MONOCHROME = "FALSE";
		defparam VGA.BITS_PER_COLOUR_CHANNEL = 1;
		defparam VGA.BACKGROUND_IMAGE = "image.colour.mif";
*/	
		
		soc_top soc_top_inst
	(
		.clk_i(CLOCK_50) ,	// input  clk_i_sig
		.reset_i(~KEY[0] | rst) ,	// input  reset_i_sig
		//imem
		.address_a_o(address_a_sig) ,	// output [14:0] address_a_sig
		.address_b_o(address_b_sig) ,	// output [14:0] address_b_sig
		.byteena_a_o(byteena_a_sig) ,	// output [3:0] byteena_a_sig
		.byteena_b_o(byteena_b_sig) ,	// output [3:0] byteena_b_sig
		.clock_a_o(clock_a_sig) ,	// output  clock_a_sig
		.clock_b_o(clock_b_sig) ,	// output  clock_b_sig
		.data_a_o(data_a_sig) ,	// output [31:0] data_a_sig
		.data_b_o(data_b_sig) ,	// output [31:0] data_b_sig
		.enable_a_o(enable_a_sig) ,	// output  enable_a_sig
		.enable_b_o(enable_b_sig) ,	// output  enable_b_sig
		.wren_a_o(wren_a_sig) ,	// output  wren_a_sig
		.wren_b_o(wren_b_sig) ,	// output  wren_b_sig
		.q_a_i(q_a_sig) ,	// input [31:0] q_a_sig
		.q_b_i(q_b_sig) ,	// input [31:0] q_b_sig
    .q_boot_i(q_boot_sig),

		//uart
		.tx_o(GPIO_0[5]) ,	// output  tx_sig
		.rx_i(GPIO_0[4]) ,	// input  rx_sig
		// spi
		.mosi_o        (GPIO_1[0]),
		.miso_i        (GPIO_1[1]),
		.SCK_o         (GPIO_1[2]),
		.slave_select_o(GPIO_1[3]),
		//i2c

		.scl_pad_i(scl_pad_i),
		.scl_pad_o(scl_pad_o),
		.scl_padoen_o(scl_padoen_o),
		.sda_pad_i(sda_pad_i),
		.sda_pad_o(sda_pad_o),
		.sda_padoen_o(sda_padoen_o),
		
		//gpio
		.gpio_oen(),
		.gpio_o({GPIO_0[3:2],LEDR}),
		.gpio_i(SW[3:0]),
		//pwm
		.pwm1_h_o      (GPIO_0[23]),
		.pwm1_l_o      (GPIO_0[24]),
		.pwm2_h_o		(GPIO_1[23]),
		.pwm2_l_o		(GPIO_1[24]),
		
		// jtag
		.tck_i(GPIO_0[0]) ,	// input  TCK_sig
		.tms_i(GPIO_0[7]) ,	// input  TMS_sig
		.tdi_i(GPIO_0[8]) ,	// input  TDI_sig
		.tdo_o(GPIO_0[9])	// output  TDO_sig
	);
	//
	
	assign GPIO_0[20] = scl_padoen_o?1'bz:scl_pad_o;
	assign scl_pad_i = GPIO_0[20];
	
	assign GPIO_0[21] = sda_padoen_o?1'bz:sda_pad_o;
	assign sda_pad_i = GPIO_0[21];

endmodule



module hex_out(data, out);
	input [3:0] data;
	output reg [7:0]out;
	always@(*)
	begin
		case (data)
			  0: out=8'b11000000;  
			  1: out=8'b11111001;
			  2: out=8'b10100100;  
			  3: out=8'b10110000;
			  4: out=8'b10011001;
			  5: out=8'b10010010;  
			  6: out=8'b10000010; 
			  7: out=8'b11111000;
			  8: out=8'b10000000;
			  9: out=8'b10010000;
			  10:out=8'b10001000;
			  11:out=8'b10000011;
			  12:out=8'b11000110;
			  13:out=8'b10100001;
			  14:out=8'b10000110;
			  15:out=8'b10001110;
		endcase
	end
endmodule
